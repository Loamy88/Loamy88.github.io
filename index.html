<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Car Cockpit Game</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.min.js"></script>
<script>
  /* scene setup */
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xa0c4ff);

  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  /* lighting */
  const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
  hemiLight.position.set(0, 20, 0);
  scene.add(hemiLight);

  const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
  dirLight.position.set(5, 10, 7.5);
  scene.add(dirLight);

  /* ground */
  const groundGeo = new THREE.PlaneGeometry(1000, 1000);
  const groundMat = new THREE.MeshStandardMaterial({ color: 0x4CAF50 });
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI / 2;
  scene.add(ground);

  /* cockpit */
  const cockpit = new THREE.Group();

  /* dashboard */
  const dashGeo = new THREE.BoxGeometry(2.5, 0.5, 1);
  const dashMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
  const dashboard = new THREE.Mesh(dashGeo, dashMat);
  dashboard.position.set(0, -0.6, -1.5);
  cockpit.add(dashboard);

  /* steering wheel */
  const wheelGroup = new THREE.Group();
  const wheelGeometry = new THREE.TorusGeometry(0.4, 0.05, 16, 100);
  const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
  const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
  wheel.rotation.y = Math.PI;
  wheelGroup.add(wheel);

  const spokeGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.4, 12);
  const spoke = new THREE.Mesh(spokeGeo, wheelMaterial);
  spoke.rotation.z = Math.PI / 2;
  wheelGroup.add(spoke);

  const center = new THREE.CylinderGeometry(0.1, 0.1, 0.05, 32);
  const centerMesh = new THREE.Mesh(center, new THREE.MeshStandardMaterial({ color: 0x888888 }));
  centerMesh.rotation.x = Math.PI / 2;
  wheelGroup.add(centerMesh);

  wheelGroup.position.set(0, -0.3, -0.6);
  cockpit.add(wheelGroup);

  /* window frame */
  const frameMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
  const frameT = 0.1, frameW = 3.5, frameH = 2, frameZ = -1.1;

  const topFrame = new THREE.Mesh(new THREE.BoxGeometry(frameW, frameT, frameT), frameMat);
  topFrame.position.set(0, frameH / 2, frameZ);
  cockpit.add(topFrame);

  const bottomFrame = new THREE.Mesh(new THREE.BoxGeometry(frameW, frameT, frameT), frameMat);
  bottomFrame.position.set(0, -frameH / 2, frameZ);
  cockpit.add(bottomFrame);

  const leftFrame = new THREE.Mesh(new THREE.BoxGeometry(frameT, frameH, frameT), frameMat);
  leftFrame.position.set(-frameW / 2 + frameT / 2, 0, frameZ);
  cockpit.add(leftFrame);

  const rightFrame = new THREE.Mesh(new THREE.BoxGeometry(frameT, frameH, frameT), frameMat);
  rightFrame.position.set(frameW / 2 - frameT / 2, 0, frameZ);
  cockpit.add(rightFrame);

  /* overlay arc */
  const overlay = document.createElement('div');
  overlay.style.position = 'absolute';
  overlay.style.top = 0;
  overlay.style.left = 0;
  overlay.style.width = '100%';
  overlay.style.height = '100%';
  overlay.style.pointerEvents = 'none';
  overlay.style.zIndex = 10;
  overlay.innerHTML = `
    <svg width="100%" height="100%" xmlns="http://www.w3.org/2000/svg">
      <path d="M0,0 Q50,80 100,0" fill="black" opacity="0.4" transform="translate(0,0) scale(${window.innerWidth / 100}, 1)"/>
    </svg>`;
  document.body.appendChild(overlay);

  camera.add(cockpit);
  camera.position.set(0, 1.5, 0);
  camera.rotation.y = Math.PI;
  scene.add(camera);

  /* obstacles */
  const obstacleGeo = new THREE.BoxGeometry(1, 2, 1);
  const obstacleMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
  for (let i = 0; i < 50; i++) {
    const obs = new THREE.Mesh(obstacleGeo, obstacleMat);
    obs.position.set((Math.random() - 0.5) * 300, 1, (Math.random() - 0.5) * 300);
    scene.add(obs);
  }

  /* movement */
  let angle = Math.PI;
  let forwardSpeed = 0;
  let steering = 0;
  const keys = {};
  const maxSpeed = 0.45;
  const accelerationRate = 0.0045;
  const reverseSpeed = -0.2;
  const decelerationRate = 0.02;

  window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
  window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

  function animate() {
    requestAnimationFrame(animate);
  
    /* steering input */
    if (keys['a']) steering = Math.min(steering + 0.0025, 0.1);
    else if (keys['d']) steering = Math.max(steering - 0.0025, -0.1);
    else steering *= 0.9;
  
    /* wheel turns opposite of car turn */
    wheelGroup.rotation.z = steering * 8;
  
    /* accelerate forward */
    if (keys['w']) {
      forwardSpeed += accelerationRate;
      forwardSpeed = Math.min(forwardSpeed, maxSpeed);
    }
  
    /* braking and reverse */
    if (keys['s']) {
      if (forwardSpeed > 0) {
        forwardSpeed -= decelerationRate;
      } else {
        forwardSpeed = reverseSpeed;
      }
    }
  
    /* friction */
    if (!keys['w'] && !keys['s']) forwardSpeed *= 0.97;
  
    /* steering changes angle */
    angle -= steering * forwardSpeed * 3;
  
    /* apply angle to camera */
    camera.rotation.y = angle;
  
    /* âœ… REVERSED DIRECTION: now camera moves in its facing direction */
    const dx = -Math.sin(angle) * forwardSpeed;
    const dz = -Math.cos(angle) * forwardSpeed;
    camera.position.x += dx;
    camera.position.z += dz;
  
    renderer.render(scene, camera);
  }


  animate();
</script>
</body>
</html>
